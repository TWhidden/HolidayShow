<%@ CodeTemplate Language="C#" TargetLanguage="C#" Debug="False" Encoding="UTF-8"
    Description="Linq to Sql DataContext Class." CompilerVersion="v3.5" %>

<%@ Assembly Name="Dbml" Path="..\..\Common" %>
<%@ Assembly Name="Generator" Path="..\..\Common" %>

<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="LinqToSqlShared.DbmlObjectModel" %>
<%@ Import Namespace="LinqToSqlShared.Generator" %>

<%@ Property Category="1.Mapping" Name="Database"
    Type="LinqToSqlShared.DbmlObjectModel.Database" Optional="False"
    Description="Database schema instance. Must be set by parent template" %>

<%@ Property Category="2.Class" Name="Framework"
    Type="LinqToSqlShared.Generator.FrameworkEnum" Default="v35_SP1" Optional="False"
    Description="Which version of the .Net Framework is being generated for." %>

<%@ Property Category="2.Class" Name="IncludeDataServices"
    Type="System.Boolean" Default="true" Optional="False"
    Description="Include ADO.Net DataServices attributes and impliment IUpdatable on DataContext." %>

<%@ Property Category="2.Class" Name="IncludeDataRules"
    Type="System.Boolean" Default="true" Optional="False"
    Description="Include CodeSmith.Data rules." %>

<%@ Property Category="2.Class" Name="DefaultConnectionString"
    Type="System.String" Optional="True"
    Description="Default Connection String Name for DatabaseContext." %>

<%@ Property Category="2.Class" Name="AuditingEnabled"
    Type="System.Boolean" Default="False" Optional="True"
    Description="Flag indicating if the default state of the AuditingEnabled property." %>

<%@ Map Name="CSharpKeyWordEscape"
    Src="CSharpKeyWordEscape.csmap" Reverse="False"
    Description="Mapping to escape c# keywords" %>

<%@ Map Name="CSharpAlias"
    Src="System-CSharpAlias.csmap" Reverse="False"
    Description="Convert system data types to c# alias" %>
#pragma warning disable 1591
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a CodeSmith Template.
//
//     DO NOT MODIFY contents of this file. Changes to this
//     file will be lost if the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;

namespace <%= Database.ContextNamespace %>
{
    /// <summary>
    /// The <see cref="System.Data.Linq.DataContext"/> class for the <%= Database.Name %> database.
    /// </summary>
    <%= Naming.GetModifier(Database.AccessModifier) %> partial class <%= Database.Class %>
        : CodeSmith.Data.Linq.DataContextBase<% if (IncludeIUpdatable) { %>, System.Data.Services.IUpdatable<% } %>
    {
        <%= GeneratedCodeAttribute %>
        public static readonly System.Data.Linq.Mapping.MappingSource MappingCache = new System.Data.Linq.Mapping.AttributeMappingSource();

        #region ConnectionString
        <%= GeneratedCodeAttribute %>
        private const string CONNECTION_NAME = "<%= DefaultConnectionString == null ? Database.Connection.SettingsPropertyName : DefaultConnectionString%>";
        <%= GeneratedCodeAttribute %>
        private static volatile string _connectionString;
        <%= GeneratedCodeAttribute %>
        private static object _connectionLock = new Object();

        /// <summary>The application connection string read from web.config or app.config</summary>
        /// <example>
        /// Add the following key to the "connectionStrings" section of your config:
        /// <code><![CDATA[
        /// <configuration>
        ///     <connectionStrings>
        ///         <add name="<%= Database.Connection.SettingsPropertyName %>"
        ///             connectionString="Data Source=(local);Initial Catalog=DATABASE;Integrated Security=True"
        ///             providerName="System.Data.SqlClient" />
        ///     </connectionStrings>
        /// </configuration>
        /// ]]></code>
        /// </example>
        <%= GeneratedCodeAttribute %>
        public static string ConnectionString
        {
            get
            {
                if (_connectionString == null)
                {
                    lock (_connectionLock)
                    {
                        if (_connectionString == null)
                            _connectionString = GetDefaultConnectionString();
                    }
                }
                return _connectionString;
            }
        }

        <%= GeneratedCodeAttribute %>
        private static string GetDefaultConnectionString()
        {
            var settings = System.Configuration.ConfigurationManager.ConnectionStrings[CONNECTION_NAME];
            if (settings == null)
            {
                string message = string.Format("Could not find the connection string '{0}' in the configuration file.  " +
                       "Please add an entry to connectionStrings section named '{0}'.", CONNECTION_NAME);
                throw new System.Configuration.ConfigurationErrorsException(message);
            }
            return settings.ConnectionString;
        }
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCode]
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>()
            : base(ConnectionString, MappingCache)
        {
            OnCreated();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The connection string.</param>
        [System.Diagnostics.DebuggerNonUserCode]
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(string connection)
            : base(connection, MappingCache)
        {
            OnCreated();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The database connection.</param>
        [System.Diagnostics.DebuggerNonUserCode]
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(System.Data.IDbConnection connection)
            : base(connection, MappingCache)
        {
            OnCreated();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The connection string.</param>
        /// <param name="mappingSource">The mapping source.</param>
        [System.Diagnostics.DebuggerNonUserCode]
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(string connection, System.Data.Linq.Mapping.MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            OnCreated();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The database connection.</param>
        /// <param name="mappingSource">The mapping source.</param>
        [System.Diagnostics.DebuggerNonUserCode]
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            OnCreated();
        }
        #endregion

        #region Tables
<% foreach (Table table in Database.Tables) { %>
        /// <summary>Represents the <%= table.Name %> table in the underlying database.</summary>
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(table.AccessModifier, table.Modifier) %> System.Data.Linq.Table<<%= Database.EntityNamespace %>.<%= table.Type.Name %>> <%= GetName(table) %>
        {
            get { return GetTable<<%= Database.EntityNamespace %>.<%= table.Type.Name %>>(); }
        }

<% } // foreach %>
        #endregion

        #region Functions
<% foreach (Function function in Database.Functions) { %>
        /// <summary>Method that is mapped to the <%= function.Name %> database procedure.</summary>
        /// <returns></returns>
        <%= CreateAttribute(function) %>
        <%= GeneratedCodeAttribute %>
        <%= Naming.GetModifier(function.AccessModifier, function.Modifier) %> <%= GetReturnType(function) %> <%= function.Method %>(<%= GetArguments(function) %>)
        {
            var methodInfo = (System.Reflection.MethodInfo)System.Reflection.MethodInfo.GetCurrentMethod();
<% if (IsTableFunction(function)) { %>
            var result = this.CreateMethodCallQuery<<%= GetResultName(function) %>>(this, methodInfo<%= GetArgumentNames(function) %>);
<% } else { %>
            var result = this.ExecuteMethodCall(this, methodInfo<%= GetArgumentNames(function) %>);
<% } %>
<%
for(int x = 0; x < function.Parameters.Count; x++) {
    Parameter p = function.Parameters[x];

    if (p.Direction == LinqToSqlShared.DbmlObjectModel.ParameterDirection.In)
        continue;

    //set out params
    Response.WriteLine("            {0} = (({1})(result.GetParameterValue({2})));",
        CSharpKeyWordEscape[p.ParameterName], GetParameterType(p), x);
}
%>

<% if (IsTableFunction(function)) { %>
            return result;
<% } else { %>
            return ((<%= GetReturnType(function) %>)(result.ReturnValue));
<% } %>
        }

<% } %>
        #endregion

        #region Extensibility Method Definitions
        /// <summary>Called after this instance is created.</summary>
        <%= GeneratedCodeAttribute %>
        partial void OnCreated();
<% foreach (Table table in Database.Tables) { %>

        /// <summary>Called before a <see cref="<%= table.Type.Name %>"/> is inserted.</summary>
        /// <param name="instance">The instance.</param>
        <%= GeneratedCodeAttribute %>
<% if (table.InsertFunction != null) { %>
        private void Insert<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance)
        {
<% if (table.InsertFunction.Arguments.Any(a => a.Version == LinqToSqlShared.DbmlObjectModel.Version.Original)) { %>
            <%= Database.EntityNamespace %>.<%= table.Type.Name %> original = <%= table.Member %>.GetOriginalEntityState(instance);

<% } // original %>
<%= GetTableFunctionCall(table.InsertFunction) %>
        }
<% } else { %>
        partial void Insert<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance);
<% } // InsertFunction%>

        /// <summary>Called before a <see cref="<%= table.Type.Name %>"/> is updated.</summary>
        /// <param name="instance">The instance.</param>
        <%= GeneratedCodeAttribute %>
<% if (table.UpdateFunction != null) { %>
        private void Update<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance)
        {
<% if (table.UpdateFunction.Arguments.Any(a => a.Version == LinqToSqlShared.DbmlObjectModel.Version.Original)) { %>
            <%= Database.EntityNamespace %>.<%= table.Type.Name %> original = <%= table.Member %>.GetOriginalEntityState(instance);

<% } // original %>
<%= GetTableFunctionCall(table.UpdateFunction) %>
        }
<% } else { %>
        partial void Update<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance);
<% } // UpdateFunction%>

        /// <summary>Called before a <see cref="<%= table.Type.Name %>"/> is deleted.</summary>
        /// <param name="instance">The instance.</param>
        <%= GeneratedCodeAttribute %>
<% if (table.DeleteFunction != null) { %>
        private void Delete<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance)
        {
<% if (table.DeleteFunction.Arguments.Any(a => a.Version == LinqToSqlShared.DbmlObjectModel.Version.Original)) { %>
            <%= Database.EntityNamespace %>.<%= table.Type.Name %> original = <%= table.Member %>.GetOriginalEntityState(instance);

<% } // original %>
<%= GetTableFunctionCall(table.DeleteFunction) %>
        }
<% } else { %>
        partial void Delete<%= table.Type.Name %>(<%= Database.EntityNamespace %>.<%= table.Type.Name %> instance);
<% } // DeleteFunction%>
<% } // foreach table%>
        #endregion
        <% if (IncludeIUpdatable) { %>

        #region IUpdatable Members
        /// <summary>
        /// Adds the specified value to the collection.
        /// </summary>
        /// <param name="targetResource">Target object that defines the property.</param>
        /// <param name="propertyName">The name of the collection property to which the resource should be added..</param>
        /// <param name="resourceToBeAdded">The opaque object representing the resource to be added.</param>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.AddReferenceToCollection(object targetResource, string propertyName, object resourceToBeAdded)
        {
            var t = targetResource.GetType();

            var collectionProperty = GetPropertyInfoForType(t, propertyName, false);
            var collection = collectionProperty.GetValue(targetResource, null) as System.Collections.IList;
            if (collection == null)
                return; // throw error

            collection.Add(resourceToBeAdded);
        }

        /// <summary>
        /// Cancels a change to the data.
        /// </summary>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.ClearChanges()
        {
            var mi = GetType().GetMethod("ClearCache",
                System.Reflection.BindingFlags.Instance |
                System.Reflection.BindingFlags.NonPublic |
                System.Reflection.BindingFlags.InvokeMethod);

            if (mi != null)
                mi.Invoke(this, null);
        }

        /// <summary>
        /// Creates the resource of the specified type and that belongs to the specified container.
        /// </summary>
        /// <param name="containerName">The name of the entity set to which the resource belongs.</param>
        /// <param name="fullTypeName">The full namespace-qualified type name of the resource.</param>
        /// <returns>
        /// The object representing a resource of specified type and belonging to the specified container.
        /// </returns>
        <%= GeneratedCodeAttribute %>
        object System.Data.Services.IUpdatable.CreateResource(string containerName, string fullTypeName)
        {
            var t = Type.GetType(fullTypeName);
            var table = GetTableForType(t);

            object value = Construct(t);
            table.InsertOnSubmit(value);

            return (value);
        }

        /// <summary>
        /// Deletes the specified resource.
        /// </summary>
        /// <param name="targetResource">The resource to be deleted.</param>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.DeleteResource(object targetResource)
        {
            var t = targetResource.GetType();
            var table = GetTableForType(t);
            table.DeleteOnSubmit(targetResource);
        }

        /// <summary>
        /// Gets the resource of the specified type identified by a query and type name.
        /// </summary>
        /// <param name="query">Language integratee query(LINQ) pointing to a particular resource.</param>
        /// <param name="fullTypeName">The fully qualified type name of resource.</param>
        /// <returns>
        /// An opaque object representing a resource of the specified type, referenced by the specified query.
        /// </returns>
        <%= GeneratedCodeAttribute %>
        object System.Data.Services.IUpdatable.GetResource(System.Linq.IQueryable query, string fullTypeName)
        {
            object result = null;

            foreach (object item in query)
            {
                if (result != null)
                    throw new System.Data.Services.DataServiceException("A single resource is expected");
                result = item;
            }

            if (result == null)
                throw new System.Data.Services.DataServiceException(404, "Resource not found");

            if (fullTypeName != null && result.GetType().FullName != fullTypeName)
                throw new System.Data.Services.DataServiceException("Resource type mismatch");

            return result;
        }

        /// <summary>
        /// Gets the value of the specified property on the target object.
        /// </summary>
        /// <param name="targetResource">An opaque object that represents a resource.</param>
        /// <param name="propertyName">The name of the property whose value needs to be retrieved.</param>
        /// <returns></returns>
        <%= GeneratedCodeAttribute %>
        object System.Data.Services.IUpdatable.GetValue(object targetResource, string propertyName)
        {
            var t = targetResource.GetType();
            var pi = GetPropertyInfoForType(t, propertyName, false);

            object value;

            try
            {
                value = pi.GetValue(targetResource, null);
            }
            catch (Exception ex)
            {
                throw new System.Data.Services.DataServiceException(
                    string.Format("Failed getting property {0} value", propertyName), ex);
            }
            return value;
        }

        /// <summary>
        /// Removes the specified value from the collection.
        /// </summary>
        /// <param name="targetResource">The target object that defines the property.</param>
        /// <param name="propertyName">The name of the property whose value needs to be updated.</param>
        /// <param name="resourceToBeRemoved">The property value that needs to be removed.</param>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.RemoveReferenceFromCollection(object targetResource, string propertyName, object resourceToBeRemoved)
        {
            var t = targetResource.GetType();

            var collectionProperty = GetPropertyInfoForType(t, propertyName, false);
            var collection = collectionProperty.GetValue(targetResource, null) as System.Collections.IList;
            if (collection == null)
                return; // throw error

            collection.Remove(resourceToBeRemoved);
        }

        /// <summary>
        /// Returns the instance of the resource represented by the specified resource object.
        /// </summary>
        /// <param name="resource">The object representing the resource whose instance needs to be retrieved.</param>
        /// <returns>
        /// Returns the instance of the resource represented by the specified resource object.
        /// </returns>
        <%= GeneratedCodeAttribute %>
        object System.Data.Services.IUpdatable.ResolveResource(object resource)
        {
            return resource;
        }

        /// <summary>
        /// Saves all the changes that have been made by using the <see cref="T:System.Data.Services.IUpdatable"/> APIs.
        /// </summary>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.SaveChanges()
        {
            try
            {
                SubmitChanges();
            }
            catch (Exception ex)
            {
                throw new System.Data.Services.DataServiceException("Error Saving Context. " + ex.GetBaseException().Message, ex);
            }
        }

        /// <summary>
        /// Sets the value of the specified reference property on the target object.
        /// </summary>
        /// <param name="targetResource">The target object that defines the property.</param>
        /// <param name="propertyName">The name of the property whose value needs to be updated.</param>
        /// <param name="propertyValue">The property value to be updated.</param>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.SetReference(object targetResource, string propertyName, object propertyValue)
        {
            ((System.Data.Services.IUpdatable)this).SetValue(targetResource, propertyName, propertyValue);
        }

        /// <summary>
        /// Sets the value of the property with the specified name on the target resource to the specified property value.
        /// </summary>
        /// <param name="targetResource">The target object that defines the property.</param>
        /// <param name="propertyName">The name of the property whose value needs to be updated.</param>
        /// <param name="propertyValue">The property value for update.</param>
        <%= GeneratedCodeAttribute %>
        void System.Data.Services.IUpdatable.SetValue(object targetResource, string propertyName, object propertyValue)
        {
            var t = targetResource.GetType();
            var pi = GetPropertyInfoForType(t, propertyName, true);

            try
            {
                pi.SetValue(targetResource, propertyValue, null);
            }
            catch (Exception ex)
            {
                throw new System.Data.Services.DataServiceException(
                  string.Format("Error setting property {0} to {1}", propertyName, propertyValue), ex);
            }
        }

        /// <summary>
        /// Updates the resource identified by the parameter <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The resource to be updated.</param>
        /// <returns></returns>
        <%= GeneratedCodeAttribute %>
        object System.Data.Services.IUpdatable.ResetResource(object resource)
        {
            var t = resource.GetType();
            var table = GetTableForType(t);
            return table.GetOriginalEntityState(resource);
        }

        <%= GeneratedCodeAttribute %>
        private System.Reflection.PropertyInfo GetPropertyInfoForType(Type t, string propertyName, bool setter)
        {
            System.Reflection.PropertyInfo pi;

            try
            {
                System.Reflection.BindingFlags flags = System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance;
                flags |= setter ? System.Reflection.BindingFlags.SetProperty : System.Reflection.BindingFlags.GetProperty;

                pi = t.GetProperty(propertyName, flags);

                if (pi == null)
                    throw new System.Data.Services.DataServiceException(
                        string.Format("Failed to find property {0} on type {1}", propertyName, t.Name));
            }
            catch (Exception exception)
            {
                throw new System.Data.Services.DataServiceException(
                    string.Format("Error finding property {0}", propertyName), exception);
            }

            return (pi);
        }

        <%= GeneratedCodeAttribute %>
        private System.Data.Linq.ITable GetTableForType(Type t)
        {
            var table = GetTable(t);
            if (table == null)
                throw new System.Data.Services.DataServiceException(string.Format("No table found for type {0}", t.Name));

            return (table);
        }

        <%= GeneratedCodeAttribute %>
        private static object Construct(Type t)
        {
            var ci = t.GetConstructor(Type.EmptyTypes);

            if (ci == null)
                throw new System.Data.Services.DataServiceException(
                    string.Format("No default ctor found for type {0}", t.Name));

            return (ci.Invoke(null));
        }
        #endregion
        <% } %>
        <% if (IncludeDataRules) { %>

        #region RuleManager
        <%= GeneratedCodeAttribute %>
        private readonly CodeSmith.Data.Rules.RuleManager _ruleManager = new CodeSmith.Data.Rules.RuleManager();

        /// <summary>
        /// Gets the current <see cref="CodeSmith.Data.Rules.RuleManager"/> for the <see cref="System.Data.Linq.DataContext"/>.
        /// </summary>
        <%= GeneratedCodeAttribute %>
        public CodeSmith.Data.Rules.RuleManager RuleManager
        {
            get { return _ruleManager; }
        }

        /// <summary>
        /// Sends changes made to retrieved objects to the underlying database.
        /// </summary>
        /// <param name="failureMode">How concurrency conflicts should be reported.</param>
        <%= GeneratedCodeAttribute %>
        public override void SubmitChanges(System.Data.Linq.ConflictMode failureMode)
        {
            bool isValid = RuleManager.Run(this);

            if (!isValid)
                throw new CodeSmith.Data.Rules.BrokenRuleException(RuleManager.BrokenRules);

            PopulateLastAudit();
            BeforeSubmitChanges();
            base.SubmitChanges(failureMode);
            RefreshLastAudit();
            AfterSubmitChanges();
        }
        #endregion

        #region Auditing
        /// <summary>Called before the underlying DataContext.SubmitChanges is called.</summary>
        <%= GeneratedCodeAttribute %>
        partial void BeforeSubmitChanges();

        /// <summary>Called after the underlying DataContext.SubmitChanges is called.</summary>
        <%= GeneratedCodeAttribute %>
        partial void AfterSubmitChanges();

        <%= GeneratedCodeAttribute %>
        private bool _auditingEnabled = <%= AuditingEnabled.ToString().ToLowerInvariant() %>;

        /// <summary>
        /// Gets or sets a value indicating whether auditing is enabled.
        /// </summary>
        /// <value><c>true</c> if auditing is enabled; otherwise, <c>false</c>.</value>
        <%= GeneratedCodeAttribute %>
        public bool AuditingEnabled
        {
            get { return _auditingEnabled; }
            set { _auditingEnabled = value; }
        }

        <%= GeneratedCodeAttribute %>
        private CodeSmith.Data.Audit.AuditLog _lastAudit;

        /// <summary>
        /// Gets the last <see cref="CodeSmith.Data.Audit.AuditLog"/>.
        /// </summary>
        /// <value>The last <see cref="CodeSmith.Data.Audit.AuditLog"/>.</value>
        /// <remarks>
        /// <see cref="AuditingEnabled"/> must be <c>true</c> for <see cref="LastAudit"/> to be populated.
        /// </remarks>
        <%= GeneratedCodeAttribute %>
        public CodeSmith.Data.Audit.AuditLog LastAudit
        {
            get { return _lastAudit; }
        }

        /// <summary>
        /// Populates the <see cref="LastAudit"/> property with the <see cref="CodeSmith.Data.Audit.AuditLog"/>
        /// of changes in this <see cref="System.Data.Linq.DataContext"/>.
        /// </summary>
        /// <remarks>
        /// <see cref="AuditingEnabled"/> must be <c>true</c> for <see cref="LastAudit"/> to be populated.
        /// </remarks>
        <%= GeneratedCodeAttribute %>
        protected virtual void PopulateLastAudit()
        {
            if (!AuditingEnabled)
                return;

            _lastAudit = CodeSmith.Data.Audit.AuditManager.CreateAuditLog(this);
        }

        /// <summary>
        /// Refresh the <see cref="AuditLog"/> values stored in the <see cref="LastAudit"/> after SubmitChanges call.
        /// </summary>
        <%= GeneratedCodeAttribute %>
        protected virtual void RefreshLastAudit()
        {
            if (_lastAudit != null) 
                CodeSmith.Data.Audit.AuditManager.Refresh(_lastAudit);
        }
        #endregion
        <% } %>

        /// <summary>
        /// Sends changes made to retrieved objects to the underlying database.
        /// </summary>
        /// <param name="refreshMode">Defines how to handle optimistic concurrency conflicts.</param>
        <%= GeneratedCodeAttribute %>
        public void SubmitChanges(System.Data.Linq.RefreshMode refreshMode)
        {
            try
            {
                SubmitChanges(System.Data.Linq.ConflictMode.ContinueOnConflict);
            }
            catch (System.Data.Linq.ChangeConflictException)
            {
                foreach (var occ in ChangeConflicts)
                    occ.Resolve(refreshMode);

                SubmitChanges();
            }
        }
    }
}
#pragma warning restore 1591

<script runat="template">
    public bool IncludeIUpdatable
    {
        get { return this.IncludeDataServices; }
    }

    public bool IsTableFunction(Function f)
    {
        return f.IsComposable == true && f.Types.Count > 0;
    }

    public string CreateAttribute(Function f)
    {
        StringBuilder s = new StringBuilder();
        s.Append("[System.Data.Linq.Mapping.Function(");
        s.AppendFormat("Name = \"{0}\"", f.Name);
        if (f.IsComposable == true)
            s.Append(", IsComposable = true");
        s.Append(")]");

        if (f.Types.Count == 0 && f.Return != null)
            s.AppendFormat("\r\n        [return: System.Data.Linq.Mapping.Parameter(DbType = \"{0}\")]", f.Return.DbType);
        else if (f.HasMultipleResults == true)
            foreach(LinqToSqlShared.DbmlObjectModel.Type t in f.Types)
                s.AppendFormat("\r\n        [System.Data.Linq.Mapping.ResultType(typeof({0}.{1}))]", Database.EntityNamespace, t.Name);

        return s.ToString();
    }

    public string GetName(Table table)
    {
        string name = string.IsNullOrEmpty(table.Member) ? table.Type.Name : table.Member;
        return name;
    }

    public string GetReturnType(Function function)
    {
        StringBuilder s = new StringBuilder();

        if (IsTableFunction(function))
            s.AppendFormat("System.Linq.IQueryable<{0}>", GetResultName(function));
        else if (function.Types.Count == 0)
            s.Append(CSharpAlias[function.Return.Type]);
        else if (function.HasMultipleResults == true)
            s.Append("System.Data.Linq.IMultipleResults");
        else
            s.AppendFormat("System.Data.Linq.ISingleResult<{0}>", GetResultName(function));

        return s.ToString();
    }

    public string GetResultName(Function function)
    {
        if (function.Types.Count == 0)
            return string.Empty;

        LinqToSqlShared.DbmlObjectModel.Type resultType = function.Types[0];
        return Database.EntityNamespace + "." + function.Types[0].Name;
    }

    public string GetArguments(Function function)
    {
        StringBuilder s = new StringBuilder();

        for(int x = 0; x < function.Parameters.Count; x++)
        {
            Parameter p = function.Parameters[x];
            s.AppendLine();
            s.AppendFormat("            [System.Data.Linq.Mapping.Parameter(Name = \"{0}\", DbType = \"{1}\")] ", p.Name, p.DbType);

            if (p.Direction != LinqToSqlShared.DbmlObjectModel.ParameterDirection.In)
                s.Append("ref ");

            s.AppendFormat("{0} {1}",GetParameterType(p), CSharpKeyWordEscape[p.ParameterName]);

            if (x < function.Parameters.Count - 1)
                s.Append(",");
        }

        return s.ToString();
    }

    public string GetParameterType(Parameter p)
    {
        if (CommonUtility.IsNullableType(p.Type))
            return CSharpAlias[p.Type] + "?";
        else
            return CSharpAlias[p.Type];
    }

    public string GetArgumentNames(Function function)
    {
        StringBuilder s = new StringBuilder();

        for(int x = 0; x < function.Parameters.Count; x++)
        {
            if (x < function.Parameters.Count)
                s.Append(", ");

            Parameter p = function.Parameters[x];
            s.Append(CSharpKeyWordEscape[p.ParameterName]);
        }

        return s.ToString();
    }

    public string GetTableFunctionCall(TableFunction tableFunction)
    {
        StringBuilder s1 = new StringBuilder();
        StringBuilder s2 = new StringBuilder();
        StringBuilder s3 = new StringBuilder();

        Function function = tableFunction.MappedFunction;

        s2.AppendFormat("            {0}(", function.Method);
        s2.AppendLine();
        for(int i = 0; i < tableFunction.Arguments.Count; i++)
        {
            TableFunctionParameter a = tableFunction.Arguments[i];
            Parameter p = function.Parameters.First(n => n.ParameterName == a.ParameterName);
            string t = GetParameterType(p);
            bool isOut = p.Direction != LinqToSqlShared.DbmlObjectModel.ParameterDirection.In;
            bool isOriginal = a.Version ==LinqToSqlShared.DbmlObjectModel.Version.Original;
            string version =  isOriginal ? "original" : "instance";
            
            // copy object to params
            if(isOut)
            {
                s1.AppendFormat("            {0} p{1} = {2}.{3};", t, i, version, a.Member);
                s1.AppendLine();
                
                s2.AppendFormat("                ref p{0}", i);
            }
            else
            {
                s2.AppendFormat("                {0}.{1}", version, a.Member);
            }

            if (i < tableFunction.Arguments.Count - 1)
            {
                s2.Append(",");
                s2.AppendLine();
            }

            // update object with out params
            if (isOut)
            {
                if (s3.Length == 0)
                    s3.AppendLine();
                
                s3.AppendFormat("            instance.{0} = p{1}", a.Member, i);
                if (CommonUtility.IsNullableType(p.Type))
                    s3.Append(".GetValueOrDefault()");
                s3.AppendLine(";");
            }
        }
        s2.AppendLine(");");
        s1.AppendLine();
        
        return s1.ToString() + s2.ToString() + s3.ToString();
    }

    private static readonly string GeneratedCodeAttribute =  string.Format(
        "[System.CodeDom.Compiler.GeneratedCode(\"CodeSmith\", \"{0}\")]",
        typeof(CodeTemplate).Assembly.GetName().Version.ToString());

</script>