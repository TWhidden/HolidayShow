<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>CodeSmith Linq to Sql Templates</title>
<style type="text/css">
.style1 {
	color: #FF0000;
}
</style>
</head>

<body>

<h1>Table of Contents</h1>
<ul>
	<li><a href="#Overview">Overview</a></li>
	<li><a href="#Features">Features</a></li>
	<li><a href="#QuickStart">Quick Start</a></li>
	<li><a href="#DoItYourself">Do It Yourself</a></li>
	<li><a href="#Dbml.cst">Dbml.cst Template</a></li>
	<li><a href="#QuickStart.cst">QuickStart.cst Template</a></li>
	<li><a href="#Entities.cst">Entities.cst Template</a></li>
	<li><a href="#Managers.cst">Managers.cst Template</a></li>
	<li><a href="#Queries.cst_Template">Queries.cst Template</a></li>
	<li><a href="#KnownIssues">Known Issues</a></li>
	<li><a href="#Roadmap">Roadmap</a></li>
	<li><a href="#Download">Download</a></li>
</ul>
<h2><a name="Overview" title="Overview"></a>Overview</h2>
<p>PLINQO, which stands for Professional LINQ to Objects, is a collection of CodeSmith 
templates that are meant to replace and extend the LINQ to SQL designers that are 
included with Visual Studio.</p>
<p>Go learn more about Plinqo even faster, please check out our Video Tutorials!<br />
<a href="http://codesmithtools.com/video/plinqo-part-1-quick-start.html">Plinqo 
Part 1: The Quick Start</a><br />
<a href="http://codesmithtools.com/video/plinqo-part-2-feature-overview.html">Plinqo 
Part 2: Feature Overview</a></p>
<h2><a name="Features" title="Features">Features</a></h2>
<p>The templates have the following features.</p>
<ul>
	<li>Generate or update a LINQ to SQL dbml file from a database schema.
	<ul>
		<li>Includes all tables, stored procedures, functions, and views with the 
		ability to exclude objects based on regex patterns.</li>
		<li>Ability to automatically remove object prefix and suffixes (ie. tbl_ 
		and usp_).</li>
		<li>Ability to standardize object names produced from database tables.</li>
		<li>Dbml file can still be customized with the normal Visual Studio designer.</li>
		<li>Dbml file can be refreshed based on the current database schema without 
		losing customizations. <em>(See Safe Attributes)</em></li>
	</ul>
	</li>
	<li>Generation of the LINQ to SQL DataContext class.</li>
	<li>Generation of the LINQ to SQL entity classes.<ul>
		<li>Generates one file per entity instead of one massive file.</li>
		<li>Generates partial classes where custom code can be written and won't 
		be overwritten.</li>
		<li>Generates Metadata classes with attribute tags from DBML information.</li>
		<li>Generated entity files are added to the project as code behind files 
		to their corresponding custom entity files.</li>
	</ul>
	</li>
	<li>Generation of entity manager classes.<ul>
		<li>Adds customizable business rules engine to enforce entity validation, 
		business and security rules based on metadata tags.</li>
		<li>Provides access to common queries based on primary keys, foreign keys, 
		and indexes.</li>
		<li>Common queries are exposed as IQueryable so they can be extended.</li>
	</ul>
	</li>
	<li>Generation of query extension methods.</li>
	<li>Generation of global.asax file for dynamic data.</li>
	<li>All templates can be customized to meet your needs.</li>
</ul>
<h2>Advantages Over Designer</h2>
<p><font class="messagecontent">There are several advantages to using the PLINQO 
templates over the Visual Studio designer. Here is a list of the main reasons:</font></p>
<ol>
	<li><font class="messagecontent">Remove the designer black box and allow for 
	customization of the output while still retaining the ability to use the .dbml 
	designer to make customizations inside of Visual Studio.</font></li>
	<li><font class="messagecontent">Ability to easily generate your entire .dbml 
	file for a database and then the ability to regenerate that .dbml file as the 
	schema changes. The regeneration preserves any customizations you may have made 
	such as entity, property and relationship names. With the designer, if you make 
	a database change, you need to drop the entity and re-add it to get any new 
	columns or data type changes, which would cause you to lose any customizations 
	you may have made. Also, using the templates allows you to exclude unwanted 
	tables, stored procedures and views using filter expressions and automatically 
	strip / clean entity and property names of things like prefixes and suffixes 
	that your database schema may be using (ie. tbl_Customer to Customer).</font></li>
	<li><font class="messagecontent">A business rules engine that allows you to 
	enforce things like property length rules, required field rules, regex data 
	validation rules as well as several other built in rules including authorization 
	rules using metadata attributes. The SubmitChanges method on the data context 
	object will automatically run the rules against any entities in your change 
	set. If all rules are not met, a BrokenRulesException will be thrown that contains 
	a list of the broken rules.</font></li>
	<li><font class="messagecontent">A manager class is generated for each entity 
	that encapsulates all actions taken on an entity. Known common actions like 
	retrieving entities by primary key, indexes, and foreign keys are generated. 
	Any custom actions can be added and will be preserved during regeneration. While 
	LINQ makes it easy to sprinkle your data access logic throughout your entire 
	application, we still believe its poor design to do so and that is why we have 
	included the manager classes. </font></li>
</ol>
<h2><a name="QuickStart" title="QuickStart">Quick Start</a></h2>
<p>The following steps will create a quick data driven site.</p>
<ol>
	<li>Open the QuickStart.cst file found in the directory with this file.</li>
	<li>Select your Datasource.</li>
	<li>Generate the template.</li>
	<li>After Visual Studio Opens, set [DataSource].UI as the startup project.</li>
	<li>Run the project.(F5)</li>
	<li>This produces a functional website using Dynamic Data, Data Services, and 
	Linq to Sql.</li>
	<li>The included csp in the data project can be used to regenerate databse informatin 
	when future changes are made.</li>
	<li>The quickstart has various properties that can be manipulalted in order 
	to produce differing base projects, including Language and ProjectType.</li>
</ol>
<h2><a name="DoItYourself" title="DoItYourself">Do It Yourself</a></h2>
<p>Use the following steps to get started using the Linq to Sql templates.</p>
<ol>
	<li>Create a new Class Library project in Visual Studio.</li>
	<li>Add a new CodeSmith project file to the Visual Studio project.<br />
	</li>
	<li>Add a new Output to the project file for the <a href="#Dbml.cst">Dbml.cst</a> 
	template.<br />
	</li>
	<li>Add another Output to the project file for the <a href="#Entities.cst">Entities.cst</a> 
	template.<br />
	</li>
	<li>Optionally, Add an Output for the <a href="#Managers.cst">Managers.cst</a> 
	template.<br />
	</li>
	<li>Set the <i>Sample.csp -&gt; Output Options -&gt; Add Outputs</i> to Project to 
	unchecked.&nbsp; The templates update the project for you.</li>
	<li>Finally, Generate the Outputs. (Figure 5)<br />
	</li>
</ol>
<h2><a name="QuickStart.cst" title="QuickStart.cst">QuickStart.cst Template</a></h2>
<p>The QuickStart.cst temlplate is used to create a basic project using Linq to 
Sql.&nbsp;&nbsp; The template will create a visual studio solution with up to three 
included projects:&nbsp;&nbsp; A Data Project, an Interface Project, and a Test 
Project. </p>
<p>Properties on the QuickStart.cst template:</p>
<table cellpadding="4">
	<tbody>
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The Database that will be accessed by the website.</td>
	</tr>
	<tr>
		<td>Language</td>
		<td>The language that thee project will be generated in.</td>
	</tr>
	<tr>
		<td>LaunchVisualStudio</td>
		<td>Should visual studio launch when the project finishes generating.</td>
	</tr>
	<tr>
		<td>Location</td>
		<td>The root directory of the generated solution.</td>
	</tr>
	<tr>
		<td>SolutionName</td>
		<td>The name of the Visual Studio Solution.</td>
	</tr>
	<tr>
		<td>VisualStudioVersion</td>
		<td>The version of Visual Studio you will be using.</td>
	</tr>
	<tr>
		<td>CopyTemplatesToFolder</td>
		<td>Create a copy of the Linq to Sql Directory and its contents to the data 
		project directory.</td>
	</tr>
	<tr>
		<td>DataProjectName</td>
		<td>The name of the data project directory and project.</td>
	</tr>
	<tr>
		<td>IncludeDataServices</td>
		<td>Include Data Service Files and References in the interface project.</td>
	</tr>
	<tr>
		<td>InterfaceProjectName</td>
		<td>The name of the interface project directory and project.</td>
	</tr>
	<tr>
		<td>ProjectType</td>
		<td>The type of interface project to be created. Can be none.</td>
	</tr>
	<tr>
		<td>IncludeTestProject</td>
		<td>Include a test project in the solution.</td>
	</tr>
	<tr>
		<td>TestProjectName</td>
		<td>The name of the test project directory and project.</td>
	</tr>
</tbody>
</table>
<h2><a name="Dbml.cst" title="Dbml.cst">Dbml.cst Template</a></h2>
<p>The Dbml.cst template is used to create a LINQ to SQL dbml file.&nbsp; The file 
conforms to the Microsoft DbmlSchema.xsd schema.&nbsp; This is the same document 
that the LINQ to SQL designer uses.&nbsp; The generated dbml file from this template 
can also be edited from the LINQ to SQL designer.&nbsp; </p>
<p>The template will create a new file if it doesn't exist.&nbsp; If the file does 
exist, the template will read it in and update it.&nbsp; This allows you to make 
changes to the file and not have it overwrite if the template is re-ran.&nbsp; However, 
only some of the attributes are safe from overwriting.&nbsp; Here is a list of safe 
attributes.&nbsp; They will be listed as an xpath.</p>
<p>Safe Attributes to change in the Dbml file ...</p>
<ul>
	<li>Database/@Class - The name of the DataContext class that will be generated.</li>
	<li>Database/@EntityNamespace - The namespace for the entity classes.</li>
	<li>Database/@ContextNamespace - The namespace for the DataContext class.</li>
	<li>Table/@Member - The property name for the table in the DataContext class.</li>
	<li>Type/@Name - The name of the entity class.</li>
	<li>Column/@Member - The property name for the column in the entity class.</li>
	<li>Column/@Storage - The private field LINQ to SQL will us to assign values 
	to.</li>
	<li>Association/@Member - The property name for this association.</li>
	<li>Association/@Storage - The private field LINQ to SQL will us to assign values 
	the association to.</li>
	<li>Association/@DeleteOnNull - Deletes row when association is set to null. 
	Value will not be persisted if the CST's IncludeDeleteOnNull Property is set 
	to false.</li>
	<li>Function/@Method - The name of the method for the database procedure.</li>
	<li>Parameter/@Parameter - The method argument name that maps to the database 
	procedure parameter.</li>
</ul>
<p><b>Warning:</b> Be aware that the template will drop tables, columns and associations 
that it did not find in the database.</p>
<p>Properties on the Dbml.cst template:</p>
<table cellpadding="4">
	<tbody>
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>CleanExpression</td>
		<td>List of regular expressions to clean table, view, column and procedure 
		names.&nbsp; Any matched text found will be removed from the name.</td>
	</tr>
	<tr>
		<td>EnumList</td>
		<td>List of regular expressions to identify an Enum Table.</td>
	</tr>
	<tr>
		<td>IgnoreList</td>
		<td>List of regular expressions used to ignore tables, views and procedures 
		when generating mapping.</td>
	</tr>
	<tr>
		<td>IncludeFunctions</td>
		<td>Include stored procedures and user functions in mapping.</td>
	</tr>
	<tr>
		<td>IncludeViews</td>
		<td>Include views in mapping.</td>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to generate the dbml file for.</td>
	</tr>
	<tr>
		<td>ContextNamespace</td>
		<td>The namespace to use for the context class file.</td>
	</tr>
	<tr>
		<td>EntityBase</td>
		<td>The base class for the entity.</td>
	</tr>
	<tr>
		<td>EntityNamespace</td>
		<td>The namespace to use for the entity class files.</td>
	</tr>
	<tr>
		<td>IncludeDeleteOnNull</td>
		<td>Templates will generated DeleteOnNull Attribute for Associations.</td>
	</tr>
	<tr>
		<td>Naming Conventions</td>
		<td>A Menu of options for naming objects in the dbml.</td>
	</tr>
	<tr>
		<td>AssociationNaming</td>
		<td>Add a list suffix or pluralize associations to an object.</td>
	</tr>
	<tr>
		<td>EntityNaming</td>
		<td>Generate entity objects in singular or plural form. </td>
	</tr>
	<tr>
		<td>TableNaming</td>
		<td>The table naming convention followed in the source database.</td>
	</tr>
	<tr>
		<td>NameColumn</td>
		<td>List of regular expressions to identify an Enum Table's Name Column.</td>
	</tr>
	<tr>
		<td>DescriptionColumm</td>
		<td>List of regular expressions to identify an Enum Table's Description 
		Column.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file to generate.</td>
	</tr>
</tbody>
</table>
<h2><a name="Entities.cst" title="Entities.cst">Entities.cst Template</a></h2>
<p>The entities template generates the entity classes needed by LINQ.&nbsp; The 
classes are generated from a dbml file.&nbsp; You can modify the names for classes 
and properties by editing the dbml file.&nbsp; See <a href="#Dbml.cst">Dbml.cst</a> 
for a list of safe attributes to change in the dbml file.</p>
<p>The template will generate 2 files for every Type in the dbml file.&nbsp; One 
file will be the generated partial class that can not be changed as it is overwritten 
when the template is re-ran.&nbsp; It will have the following file name... &lt;entity&gt;.Generated.cs</p>
<p>The second file is a partial class that can be modified as it will not be re-generated.&nbsp; 
You can implement the partial methods in this file.&nbsp; Some partial method stubs 
are created by default. This file will be named... &lt;entity&gt;.cs</p>
<p>If you set the project file property on the template, the generated files will 
be added to the project.&nbsp; The file that can not be modified will be hidden 
under the file that can be changed.</p>
<p>Properties on the Entities.cst template:</p>
<table cellpadding="4">
	<tbody>
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the entities from.</td>
	</tr>
	<tr>
		<td>Framework</td>
		<td>The version of the .Net Framework that is being used. Version 35_1 is 
		necessary for dynamic data and data services attributes.</td>
	</tr>
	<tr>
		<td>IncludeDataContract</td>
		<td>Include serialization attributes on the generated entities. The attributes 
		generated are based on the framework attribute above.</td>
	</tr>
	<tr>
		<td>IncludeDataServices</td>
		<td>Include Data Services attributes on the generated entities.</td>
	</tr>
	<tr>
		<td>OutputDirectory</td>
		<td>The folder to save the generated files.</td>
	</tr>
</tbody>
</table>
<h2><a name="Managers.cst" title="Managers.cst">Managers.cst Template</a></h2>
<p>The manager template is for helping you get started with business logic for the 
LINQ entities.&nbsp; The managers will have common queries that are created from 
keys and indexes on the table.&nbsp; The manager will also have rules for the entity 
properties to make sure required fields are not null and that the length of a string 
does not exceed the max length the column allows.</p>
<p>The template works by creating a second partial class that has a Manager property.&nbsp; 
The manager will then have a property for each entity that has a manager. Here is 
a sample of the syntax for using the managers:</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: #2b91af;">SampleDataContext
	</span>db = <span style="color: blue;">new</span>
	<span style="color: #2b91af;">SampleDataContext</span>();</p>
	<p style="margin: 0px;"><span style="color: green;">// use the primary key</span></p>
	<p style="margin: 0px;"><span style="color: #2b91af;">Task</span> task = db.Manager.Task.GetByKey(taskId);</p>
	<p style="margin: 0px;"><span style="color: green;">// use a foreign key</span></p>
	<p style="margin: 0px;"><span style="color: blue;">var</span> myTasks = db.Manager.Task.GetByAssignedID(userId);</p>
	<p style="margin: 0px;"><span style="color: green;">// the methods return IQueryable 
	so you can add expressions</span></p>
	<p style="margin: 0px;"><span style="color: blue;">var</span> openTasks = db.Manager.Task.GetByStatusID(statusId).OrderBy(t 
	=&gt; t.CreateDate);</p>
</div>
<p>The manager will add business rules to your entities based on metadata attributes. 
These rules are based on the same rules found in the DataAnnotations.</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: blue;">private</span>
	<span style="color: blue;">class</span><span style="color: #2b91af;"> Metadata</span></p>
	<p style="margin: 0px;">{</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Only 
	Attributes in the class will be preserved.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">int</span> OrderId { <span style="color: blue;">get</span>;
	<span style="color: blue;">set</span>; }</p>
	<p></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Required</span>]</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">StringLength</span>(20)]</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">string</span> UserId { <span style="color: blue;">
	get</span>; <span style="color: blue;">set</span>; }</p>
	<p></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Range</span> 
	(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">DateTime</span>),
	<span style="color: #a31515;">&quot;10-31-2008&quot;</span>,
	<span style="color: #a31515;">&quot;12-25-2200&quot;</span>)]</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span> 
	System.<span style="color: #2b91af;">DateTime</span> OrderDate {
	<span style="color: blue;">get</span>; <span style="color: blue;">set</span>; 
	}</p>
	<p>.......</p>
	<p style="margin: 0px;">}</p>
</div>
<p>The manager also provides a business rules engine to your entities. In addition 
to the default validation rules that are generated, you can add custom rules by 
implementing the AddRules partial method in the custom entity class.</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: blue;">static</span>
	<span style="color: blue;">partial</span> <span style="color: blue;">void</span> 
	AddRules()</p>
	<p style="margin: 0px;">{</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	allows the Name property to be a max of 150 characters.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	LengthRule(<span style="color: #a31515;">&quot;Name&quot;</span>, 150));</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	that validates the value of the property using regex.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	RegexRule(<span style="color: #a31515;">&quot;Name&quot;</span>,
	<span style="color: #a31515;">&quot;.*&quot;</span>));</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	allows only users in certain security roles to update.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	UpdateRule(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">new</span> <span style="color: blue;">string</span>[] 
	{ <span style="color: #a31515;">&quot;Administrator&quot;</span>,
	<span style="color: #a31515;">&quot;Updaters&quot;</span> }));</p>
	<p style="margin: 0px;">}</p>
</div>
<p>Properties on the Managers.cst template:</p>
<table cellpadding="4">
	<tbody>
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to keys and indexes from for generating the manager 
		classes.</td>
	</tr>
	<tr>
		<td>Framework</td>
		<td>The version of the .Net Framework that is being used.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the manager classes from.</td>
	</tr>
	<tr>
		<td>DataContextFile</td>
		<td>The location of the DataContext File.</td>
	</tr>
	<tr>
		<td>DataContextName</td>
		<td>The class name of the DataContext that supports the managers.</td>
	</tr>
	<tr>
		<td>ManagerDirectory</td>
		<td>The folder to save the generated manager files.</td>
	</tr>
	<tr>
		<td>ManagerNamespace</td>
		<td>The namespace to use for the generated manager class files.</td>
	</tr>
</tbody>
</table>
<h2><a name="Queries.cst_Template">Queries.cst Template</a></h2>
<p>The queries template is an optional alternative to the manager template.&nbsp; 
If you don't want to use the manager framework, you can use this template to generate 
some common queries for an entity.&nbsp; While its possible to use both the manger 
and query templates, they do duplicate some functionality. The template works by 
generating an extension class for Table&lt;Entity&gt;.&nbsp; This allows the queries to 
be off the DataContext.</p>
<!--
{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Consolas;}}{\colortbl;??\red43\green145\blue175;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue255;}??\fs20 \cf1 SampleDataContext\cf0  db = \cf4 new\cf0  \cf1 SampleDataContext\cf0 ();\par ??\cf1 Task\cf0  task = db.Task.GetByID(1);\par ??}
-->
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: #2b91af;">SampleDataContext</span> 
	db = <span style="color: blue;">new</span> <span style="color: #2b91af;">SampleDataContext</span>();</p>
	<p style="margin: 0px;"><span style="color: #2b91af;">Task</span> task = db.Task.GetByKey(1);</p>
</div>
<!--endfragment--><p>This is an example of what the extension class looks like.</p>
<!--
{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Consolas;}}{\colortbl;??\red128\green128\blue128;\red255\green255\blue255;\red0\green128\blue0;\red0\green0\blue255;\red0\green0\blue0;\red43\green145\blue175;}??\fs20 \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??///\cf3  The query extension class for Task.\par ??\cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf4 public\cf0  \cf4 static\cf0  \cf4 partial\cf0  \cf4 class\cf0  \cf6 TaskQueryExtension\par ??\cf0 \{\par ??    \par ??    \par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets an instance by the primary key.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 Task\cf0  GetByTaskID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  taskID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByTaskID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, taskID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.FirstOrDefault(t =&gt; t.TaskID == taskID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByStatusID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  statusID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByStatusID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, statusID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.StatusID == statusID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByPriorityID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  priorityID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByPriorityID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, priorityID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.PriorityID == priorityID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByCreatedID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  createdID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByCreatedID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, createdID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.CreatedID == createdID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByAssignedID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  assignedID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByAssignedID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, assignedID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.AssignedID == assignedID);\par ??    \}\par ??\par ??\cf4     #region\cf0  Query\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  A private class for lazy loading static compiled queries.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 private\cf0  \cf4 static\cf0  \cf4 partial\cf0  \cf4 class\cf0  \cf6 Query\par ??\cf0     \{\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 Task\cf0 &gt; GetByTaskID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  taskID) =&gt; \par ??                    db.Task.FirstOrDefault(t =&gt; t.TaskID == taskID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByStatusID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  statusID) =&gt; \par ??                    db.Task.Where(t =&gt; t.StatusID == statusID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByPriorityID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  priorityID) =&gt; \par ??                    db.Task.Where(t =&gt; t.PriorityID == priorityID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByCreatedID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  createdID) =&gt; \par ??                    db.Task.Where(t =&gt; t.CreatedID == createdID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByAssignedID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  assignedID) =&gt; \par ??                    db.Task.Where(t =&gt; t.AssignedID == assignedID));\par ??\par ??    \}\par ??\cf4     #endregion\par ??\cf0 \}\par ??}
-->
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;"> 
	The query extension class for Task.</span></p>
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;"><span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: blue;">partial</span>
	<span style="color: blue;">class</span> <span style="color: #2b91af;">TaskQueryExtension</span></p>
	<p style="margin: 0px;">{</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	Gets an instance by the primary key.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: #2b91af;">Task</span> 
	GetByKey(<span style="color: blue;">this</span>
	<span style="color: #2b91af;">Table</span>&lt;<span style="color: #2b91af;">Task</span>&gt; 
	entity, <span style="color: blue;">int</span> taskID)</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">if</span> (entity.Context.LoadOptions ==
	<span style="color: blue;">null</span>) </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> <span style="color: #2b91af;">Query</span>.GetByKey.Invoke((<span style="color: #2b91af;">SampleDataContext</span>)entity.Context, 
	taskID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">else</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> entity.FirstOrDefault(t =&gt; t.TaskID 
	== taskID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	Gets a query by an index.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: #2b91af;">IQueryable</span>&lt;<span style="color: #2b91af;">Task</span>&gt; 
	GetByStatusID(<span style="color: blue;">this</span>
	<span style="color: #2b91af;">Table</span>&lt;<span style="color: #2b91af;">Task</span>&gt; 
	entity, <span style="color: blue;">int</span> statusID)</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">if</span> (entity.Context.LoadOptions ==
	<span style="color: blue;">null</span>) </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> <span style="color: #2b91af;">Query</span>.GetByStatusID.Invoke((<span style="color: #2b91af;">SampleDataContext</span>)entity.Context, 
	statusID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">else</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> entity.Where(t =&gt; t.StatusID == statusID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;"><span style="color: blue;">&nbsp;&nbsp;&nbsp; #region</span> 
	Query</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	A private class for lazy loading static compiled queries.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">private</span>
	<span style="color: blue;">static</span> <span style="color: blue;">partial</span>
	<span style="color: blue;">class</span> <span style="color: #2b91af;">Query</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">internal</span> <span style="color: blue;">static</span>
	<span style="color: blue;">readonly</span> <span style="color: #2b91af;">Func</span>&lt;<span style="color: #2b91af;">SampleDataContext</span>,
	<span style="color: blue;">int</span>, <span style="color: #2b91af;">Task</span>&gt; 
	GetByKey = </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: #2b91af;">CompiledQuery</span>.Compile(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	(<span style="color: #2b91af;">SampleDataContext</span> db,
	<span style="color: blue;">int</span> taskID) =&gt; </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	db.Task.FirstOrDefault(t =&gt; t.TaskID == taskID));</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">internal</span> <span style="color: blue;">static</span>
	<span style="color: blue;">readonly</span> <span style="color: #2b91af;">Func</span>&lt;<span style="color: #2b91af;">SampleDataContext</span>,
	<span style="color: blue;">int</span>, <span style="color: #2b91af;">IQueryable</span>&lt;<span style="color: #2b91af;">Task</span>&gt;&gt; 
	GetByStatusID = </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: #2b91af;">CompiledQuery</span>.Compile(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	(<span style="color: #2b91af;">SampleDataContext</span> db,
	<span style="color: blue;">int</span> statusID) =&gt; </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	db.Task.Where(t =&gt; t.StatusID == statusID));</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;"><span style="color: blue;">&nbsp;&nbsp;&nbsp; #endregion</span></p>
	<p style="margin: 0px;">}</p>
</div>
<!--endfragment--><p>Properties on the Queries.cst template:</p>
<table cellpadding="4">
	<tbody>
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to keys and indexes from for generating the manager 
		classes.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the query classes from.</td>
	</tr>
	<tr>
		<td>QueryDirectory</td>
		<td>The folder to save the generated query extension files.</td>
	</tr>
	<tr>
		<td>ProjectFile</td>
		<td>The Visual Studio project file to add the generated files to.</td>
	</tr>
</tbody>
<h2><a name="KnownIssues" title="KnownIssues"></a>Known Issues</h2>
<ul>
	<li>The generated DataContext does not set the connection string like the LINQ 
	to SQL designer</li>
</ul>
<h2><a name="Roadmap" title="Roadmap"></a>Roadmap</h2>
<ul>
	<li>Unit test generation</li>
	<li>Web service generation</li>
	<li>ASP.NET, Winforms and WPF UI generation</li>
</ul>
<h2><a name="Download"></a>Download</h2>
<p>Download the latest release of PLINQO.</p>
<ul>
	<li><a href="http://code.google.com/p/codesmith/downloads/list">Latest Release</a></li>
	<li><a href="http://community.codesmithtools.com/nightly/plinqo/">Nightly Builds</a></li>
</ul>
<h2>History</h2>
<ul>
	<li>Release 5.0.4<ul>
		<li>Fix bug with GetHashKey and Contains not being unique</li>
		<li>Fixed a bug where the DataContext was not being named correctly.</li>
		<li>Updated PLINQO Interfaces to inlcude associations</li>
		<li>Fix issue with Transaction and GetCommand</li>
	</ul>
	</li>
	<li>Release 5.0.3<ul>
		<li>Fix to remove unprocessed function types and columns</li>
		<li>Updated the syntax for invoking stored procedures.</li>
		<li>Fix issues with AuditLog by adding a Refresh method on AuditManager</li>
		<li>Add support for XmlReader to AuditLog</li>
		<li>Add support for table CRUD mapped to functions</li>
	</ul>
	</li>
	<li>Release 5.0.1<ul>
		<li>Added IncludeList property to dbml template to support explicit include</li>
		<li>Fixed keyword escape issues in functions</li>
		<li>Added Serializable attribute to entities</li>
		<li>Added QueryNamespace property to queries template so queries can be 
		in a different namespace</li>
		<li>Make enums use full namespace to prevent naming issues</li>
		<li>Fixed issue with many to many association error &quot;An item with the same 
		key has already been added.&quot;</li>
		<li>Updated vb function to use correct ByRef or ByVal in parameters</li>
		<li>Fixed issue for cache on different databases</li>
		<li>Fixed include list to not prevent association generation</li>
		<li>Fixed issue with cache default profile</li>
		<li>Fix to make IsPrimaryKey sync correctly</li>
		<li>Fixed issue initializing PLINQO rules asynchronously</li>
	</ul>
	</li>
	<li>Release 5.0
	<ul>
		<li>Added Visual Studio 2010 and .NET 4 Support</li>
		<li>Updated QuickStart with latest Dynamic Data and DataServices</li>
		<li>Added SQLCacheDependancy Support</li>
		<li>Added IQueryable Cache Extensions</li>
		<li>Added Include extension for advanced eager loading </li>
		<li>Improved AuditLog, now includes updates after SubmitChanges</li>
		<li>Fixed bug in CacheManager where default profile did not load properly</li>
		<li>Added override RuleManager.Run override that populates the TrackedObject.Original</li>
		<li>Fixed bug in AuditLog</li>
		<li>Fixed bugs in VB Quick Start</li>
		<li>Added DataContextName to QuickStart.cst</li>
		<li>Fixed Managers didn't have the same access modifier as entities</li>
		<li>Fixed bug in GetByKey function in VB</li>
		<li>Fixed invalid cast exception for Range attribute on short properties</li>
		<li>Fixed bug in ExecuteFutureQueries when no queries were loaded</li>
		<li>Fixed bug in Manager when column didn't exist </li>
		<li>Added logic to skip columns of type 'hierarchyid'</li>
		<li>Added work around for L2S Profiler not working with transactions</li>
		<li>Fixed bug where Metadata property types did not match up with Enums</li>
		<li>Added BeginTransaction with no overload</li>
	</ul>
	</li>
	<li>Release 4.0.1
	<ul>
		<li class="style1">Change to argument order of operators to make it more 
		clear which is the left and right side of the operation</li>
		<li>Add NextPage, PreviousPage, GotPage to PagedList</li>
		<li>Update CodeSmith.Data.chm to have correct email address for suppor</li>
		<li>Add methods GetOrSet to CacheManager and CacheProvider</li>
		<li>Add BeginTransaction to DataContextExtensions</li>
		<li>Add GeneratedCodeAttribute to Generated classes</li>
		<li>Fix issue with duplicate many to many names</li>
		<li>Add full namespace to Metadata class</li>
		<li>Fix bug in LinqCacheDataSource</li>
		<li>Add DataContextName to dbml template and Generator</li>
		<li>Change default Clean Expression to be less aggressive </li>
		<li>Added Current and Original entities to AuditEntity.</li>
		<li>&nbsp;Fixed a bug loading NRefactory causing the templates not to compile</li>
		<li>Add NotNull Rule and Attribute.</li>
		<li>Fix bug with Update and TimeSpan data type.</li>
		<li>Fix issue with column named &quot;Key&quot;</li>
		<li>Change ViewDirectory to ModelDirectory</li>
		<li>Change comments in Entity.Editable.cst</li>
		<li>Fix ToBinary</li>
		<li>Improve sql generated with null valuese</li>
	</ul>
	</li>
	<li>Release 4.0
	<ul>
		<li>Added future query support similar to NHibernate Futures </li>
		<li>Added ability to query by null to query extensions </li>
		<li>Added ability to query by a list of values to query extensions </li>
		<li>Added ability to query using comparison operators (ie. greater than, 
		less than) to query extensions </li>
		<li>Added cache provider support </li>
		<li>Added support for using Ayende's LINQ to SQL Profiler </li>
		<li>Added Memcached cache provider </li>
		<li>Added ability to create named cache profiles in configuration </li>
		<li>Added ability to validate individual entities </li>
		<li>Refactored RuleManager to lazy load shared rules </li>
		<li>Combined extension method namespaces to make the extension methods more 
		discoverable </li>
		<li>Added support for SQL Server user defined functions </li>
		<li>Added entity interfaces to help with mocking and other uses </li>
		<li>Updated ToPagedList() to use future queries for retrieving the total 
		row count </li>
		<li>Added ToBinary(), FromBinary(), and FromXml() methods to help with entity 
		serialization </li>
		<li>Added UTC support for the Now attribute and rule </li>
		<li>Added ClearCache() to remove queries from the cache </li>
		<li>Fixed several bugs with batch queries </li>
		<li>Many other bug fixes and small enhancements listed on the CodeSmith 
		Google Code project site. </li>
	</ul>
	</li>
	<li>Release 3.1<ul>
		<li>Added query result caching.</li>
		<li>Added a new AlwaysAuditAttribute to make it possible to always audit 
		a property even if it hasn't changed.</li>
		<li>Added partial change tracking methods for EntityRef associations.</li>
		<li>Added support for maintaining user defined associations.</li>
		<li>Added partial change tracking methods for EntityRef associations.</li>
		<li>Added shared version information for Assemblies.</li>
		<li>Added support for AuditPropertyFormat.</li>
		<li>Removed AddRule that is no longer used in manager templates.</li>
		<li>Updated manager templates classes to lazy load.</li>
		<li>Fixed many to many issue when IncludeDeleteOnNull is false.</li>
		<li>Fixed bug with a keyword in function parameter name.</li>
		<li>Fixed bug with transactions in ExecuteQuery.</li>
		<li>Fixed bug with nullable columns in queries.</li>
		<li>Fixed bug with nullable parameter in query.</li>
		<li>Fixed support for inheritance.</li>
	</ul>
	</li>
	<li>Release 3.0<ul>
		<li>Added Entity Detach.</li>
		<li>Added Entity Clone.</li>
		<li>Added support for Many-to-Many Relationships.</li>
		<li>Added auditing.</li>
		<li>Added Batch Updates and Deletes.</li>
		<li>Added support for multiple result sets.</li>
	</ul>
	</li>
	<li>Release 2.x<ul>
		<li>Added Enum table support.</li>
		<li>Added Many To Many association support.</li>
		<li>Added Detach method to Context.</li>
		<li>Added ICloneable on Business Entities.</li>
		<li>Updated Insert Class Merge Strategy to support merging Namespaces.</li>
		<li>Fix Issue with DeleteOnNull persisting when IncludeDeleteOnNull set 
		to False.</li>
	</ul>
	</li>
	<li>Release 2.0<ul>
		<li>Added Quickstart template to allow quick generation of a Plinqo based 
		web project.</li>
		<li>Added various Naming Convention properties to give better control over 
		object naming standards. </li>
		<li>Added Dynamic Data support to generated entities.</li>
		<li>Added Metadata Internal class.</li>
		<li>LinqEntityBase now has an editable parent file.</li>
		<li>Manager produces rules based on MetaData Attributes</li>
		<li>Added Global.asax Template</li>
		<li>Entity Serialization adds functionality based on .Net framework version.</li>
		<li>Added Data Services support.</li>
	</ul>
	</li>
	<li>Release 1.3<ul>
		<li>added GetByKey(IEntityKey) common method for manager template</li>
		<li>made managers inherit from base classes in manager template</li>
		<li class="style1">made primary key query use common name GetByKey in manager 
		and query templates</li>
		<li>fix namespace issues when context and entity namespaces aren't the same</li>
		<li>fix QueryExtension with wrong context name</li>
		<li>fix CompiledQuery issue when there are more then four columns</li>
		<li>fix issue with compiled queries and load options</li>
		<li>fix bugs when dbml file is loaded in designer </li>
		<li>add support for adding the ConnectionString to the settings file
		</li>
		<li>added Queries.cst to support query extension Methods </li>
		<li class="style1">&nbsp;removed manager data context, now another partial 
		of the DataContext</li>
		<li>added support for unique indexes</li>
		<li>added range rule for dates</li>
		<li>update to .net 3.5 RTM</li>
	</ul>
	</li>
	<li>Release 1.2<ul>
		<li>Fix LinqDataSource issue by making all properties writable</li>
		<li>Added CompiledQuery support to the manager classes</li>
		<li>Added support for overriding the column data type </li>
	</ul>
	</li>
	<li>Release 1.1<ul>
		<li>Changed to use dbml schema as meta data</li>
		<li>Split templates up to allow more flexibility</li>
		<li>Added function, table inheritance, ignoring, and name cleaning support</li>
	</ul>
	</li>
</ul>
<p>&nbsp;</p>
<p class="style1">*Breaking change</p>

</body>

</html>